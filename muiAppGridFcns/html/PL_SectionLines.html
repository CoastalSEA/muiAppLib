
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>PL_SectionLines</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2025-03-06"><meta name="DC.source" content="PL_SectionLines.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> PL_SectionLines &lt; PLinterface
</pre><pre class="codeinput"><span class="comment">%</span>
<span class="comment">%-------class help---------------------------------------------------------</span>
<span class="comment">% NAME</span>
<span class="comment">%   PL_SectionLines.m</span>
<span class="comment">% PURPOSE</span>
<span class="comment">%   Class to create a set of cross-sections lines based on the points in a</span>
<span class="comment">%   centre-line and any enclosing boundary</span>
<span class="comment">% USAGE</span>
<span class="comment">%</span>
<span class="comment">% SEE ALSO</span>
<span class="comment">%   inherits PLinterface</span>
<span class="comment">%</span>
<span class="comment">% Author: Ian Townend</span>
<span class="comment">% CoastalSEA (c) Feb 2025</span>
<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">%</span>
    properties (Transient)
        <span class="comment">%set Abstract properties for PLinterface</span>
        outPoints = [] <span class="comment">%not used but has to be set</span>
        isXYZ = false  <span class="comment">%not used but has to be set</span>
        outLines = []
        Set            <span class="comment">%instance of PL_Sections class, or struct with</span>
                       <span class="comment">%same field names</span>
        cLines         <span class="comment">%updated plines version of Set.ChannelLine (modified</span>
                       <span class="comment">%when sections are set but not saved)</span>
        xLength        <span class="comment">%half length of cross-sections</span>
    <span class="keyword">end</span>

    methods
        <span class="keyword">function</span> obj = PL_SectionLines(figtitle,tag,position)
            <span class="comment">%constructor code:</span>
            <span class="keyword">if</span> nargin&lt;3, position = []; <span class="keyword">end</span>
            obj = setFigure(obj,figtitle,tag,position);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in PL_SectionLines (line 34)
            obj = setFigure(obj,figtitle,tag,position);
</pre><pre class="codeinput">    methods (Static)
        <span class="keyword">function</span> [slines,clines] = Figure(grid,promptxt,sobj,isdel)
            <span class="comment">%</span>
            <span class="comment">%-------function help------------------------------------------</span>
            <span class="comment">% PURPOSE</span>
            <span class="comment">%   Figure to interactively edit points or lines</span>
            <span class="comment">% USAGE</span>
            <span class="comment">%   lines = PL_SectionLines.Figure(grid,promptxt,sobj,isdel);</span>
            <span class="comment">% INPUTS</span>
            <span class="comment">%   grid - struct of x, y, z (eg as used in getGrid in the GDinterface)</span>
            <span class="comment">%   promptxt- character string used for initial prompt in title</span>
            <span class="comment">%   sobj - instance of the PL_Sections class properties</span>
            <span class="comment">%          Boundary, ChannelLine, and ChannelProps a struct</span>
            <span class="comment">%          for maximum water level, depth exponent and sampling</span>
            <span class="comment">%          interval (maxwl,dexp,cint)</span>
            <span class="comment">%   isdel - logical flag true to delete figure on completion - optional,</span>
            <span class="comment">%           default is false</span>
            <span class="comment">% OUTPUTS</span>
            <span class="comment">%   lines - if lines are input, format is the same as the input, otherwise</span>
            <span class="comment">%           if nlines is scalar (default it type 2 if nlines empty)</span>
            <span class="comment">%            outype=0: array of structs with x, y and z fields defining selected points,</span>
            <span class="comment">%            outype=1: Nx2 or Nx3 array.</span>
            <span class="comment">%            outype=2: struct with x, y (and z) vector fields</span>
            <span class="comment">%            outype=3: table with x, y (and z) vector fields</span>
            <span class="comment">%            lines = [] if user closes figure, or no points defined</span>
            <span class="comment">% NOTES</span>
            <span class="comment">%   NB: if the figure window is closed the function returns lines=[] and</span>
            <span class="comment">%       not the input points</span>
            <span class="comment">%--------------------------------------------------------------</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin&lt;4, isdel = false; <span class="keyword">end</span>
            figtitle = sprintf(<span class="string">'Extract centre-line'</span>);
            tag = <span class="string">'PlotFig'</span>; <span class="comment">%used for collective deletes of a group</span>
            position = [0,0.03,1,0.93];
            obj = PL_SectionLines(figtitle,tag,position);

            <span class="comment">%plot grid and initialise axes (needed for context menus)</span>
            obj.Axes = plotGrid(obj,grid);
            obj.Axes.Title.String = promptxt; <span class="comment">%initial prompt</span>

            <span class="comment">%define menu to be used</span>
            mtext = {<span class="string">'Sections'</span>,<span class="string">'Figure'</span>};
            mcall = repmat({[]},1,length(mtext));
            menu = struct(<span class="string">'label'</span>,mtext,<span class="string">'callback'</span>,mcall);
            <span class="comment">%default menus are defined for Point, Line and Figure include:</span>
            <span class="comment">% Line: 'Add','Edit','Extend','Insert','Join','Split','Delete'</span>
            <span class="comment">% Figure: 'View','Undo','Save','Save &amp; Exit','Quit'</span>
            <span class="comment">%and are defined in PLinterface. getCallBacks</span>
            <span class="comment">%Bespoke options are then added by creating tables for each</span>
            <span class="comment">%addtional menu option in the function setSubMenus</span>
            submenus = setSubMenus(obj);
            <span class="comment">%set the menus and submenus</span>
            obj = setMenu(obj,menu,submenus);
            obj.Set = sobj;                       <span class="comment">%used to access PL_Sections for reset</span>
            <span class="keyword">if</span> ~isempty(sobj.Boundary)
                b_lines = obj.Set.Boundary;           <span class="comment">%Boundary coordinates</span>
                hold <span class="string">on</span>
                plot(obj.Axes,b_lines.x,b_lines.y,<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1);
                hold <span class="string">off</span>;
            <span class="keyword">end</span>

            obj.cLines = gd_lines2points(obj.Set.ChannelLine);<span class="comment">%Centre line coordinates</span>
            gd_plotpoints(obj.Axes,obj.cLines,<span class="string">'clines'</span>,5);    <span class="comment">%5= plot as centre-lines</span>

            <span class="comment">%handle input of existing lines</span>
            outype = getInLines(obj,obj.Set.SectionLines);

            obj.Figure.Visible = <span class="string">'on'</span>;
            obj = waitForFigure(obj);

            <span class="keyword">if</span> isempty(obj.outLines)
                slines = []; clines = [];
            <span class="keyword">else</span>
                slines = gd_points2lines(obj.outLines,outype.lines);
                clines = gd_points2lines(obj.cLines,outype.lines);
            <span class="keyword">end</span>

            <span class="comment">%delete figure if isdel has been set by call.</span>
            <span class="keyword">if</span> isdel
                delete(obj.Figure)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">% Additional Menu callback functions</span>
<span class="comment">%--------------------------------------------------------------------------</span>
    methods (Access=protected)
</pre><pre class="codeinput">        <span class="keyword">function</span> setSections(obj,~,~)
            <span class="comment">%use centreline to generate a set of sections</span>
            resetMenu(obj);
            clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'mypoints'</span>,<span class="string">'mytext'</span>});
            setSectionLength(obj);

            <span class="comment">%get user to define the mouth by defining a point near to a point on the</span>
            <span class="comment">%channel centre-line</span>
            promptxt = <span class="string">'Left click to set mouth point, right click to quit'</span>;
            ok = 0;
            axes(obj.Axes)
            tol = (abs(diff(xlim))+abs(diff(ylim)))/2/100; <span class="comment">%(1e4+1e5)/2/100~O[300m]</span>
            <span class="keyword">while</span> ok&lt;1
                [mpnt,hp] = gd_setpoint(obj.Axes,promptxt,<span class="string">'startpoint'</span>,false);
                delete(hp)
                <span class="keyword">if</span> isempty(mpnt)
                    ok = 2;  <span class="comment">%user cancelled</span>
                <span class="keyword">else</span>
                   [isNear,idL] = PLinterface.isPointNearLine(obj.cLines,mpnt,tol);
                   <span class="keyword">if</span> isNear
                       ok = 1;
                   <span class="keyword">else</span>
                       answer = questdlg(<span class="string">'Could not find point. Try again?'</span>,<span class="keyword">...</span>
                                              <span class="string">'Sections'</span>,<span class="string">'Yes'</span>,<span class="string">'No'</span>,<span class="string">'Yes'</span>);
                       <span class="keyword">if</span> strcmp(answer,<span class="string">'No'</span>), ok = 2; <span class="keyword">end</span>
                   <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> ok==1
                <span class="comment">%for each point from idL to the end use the centreline coordinates and</span>
                <span class="comment">%direction to define a section at right angles to the centreline</span>
                c_cplines = gd_plines2cplines(obj.cLines);
                [clinedir,c_cplines,~] = gd_curvelineprops(c_cplines,idL(1));

                <span class="comment">%generate the section lines for clinedir +pi/2 and -pi/2</span>
                obj.pLines = setSectionLines(obj,c_cplines,clinedir,obj.xLength);
                obj.cLines = gd_cplines2plines(c_cplines);
                plotSections(obj);
            <span class="keyword">end</span>
            resetMenu(obj,false)
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> clipLines(obj,~,~)
            <span class="comment">%clip the extent of the sections lines to a defined boundary</span>
            resetMenu(obj);
            c_lines = obj.cLines;
            c_lines(isnan([c_lines(:).x])) = [];   <span class="comment">%remove Nans so only points</span>
            ncentres = length(c_lines);            <span class="comment">%number of centreline points</span>

            s_cplines = gd_plines2cplines(obj.pLines);  <span class="comment">%section lines</span>
            nsections = length(s_cplines);
            <span class="keyword">if</span> nsections~=ncentres
                warndlg(<span class="string">'Number of sections do not match number of points on centre-lines'</span>)
                <span class="keyword">return</span>;
            <span class="keyword">else</span>
                c_lines = gd_points2lines(c_lines,1);
            <span class="keyword">end</span>
            <span class="comment">%crop lines to first crossing of boundary line</span>
            [s_lines,idc] = clipSectionLines(obj,s_cplines,c_lines);
            obj.pLines = gd_lines2points(s_lines);

            <span class="comment">%idc is the centre-line index of deleted points excluding NaNs</span>
            <span class="keyword">for</span> i=1:length(idc)
                 idd = find([obj.cLines(:).x]==c_lines(idc(i),1) &amp; <span class="keyword">...</span>
                                    [obj.cLines(:).y]==c_lines(idc(i),2));
                 <span class="keyword">if</span> ~isempty(idd), obj.cLines(idd) = []; <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">%check that all points in a reach have not been deleted</span>
            cplines = gd_plines2cplines(obj.cLines);
            <span class="keyword">for</span> j=1:length(cplines)
                <span class="keyword">if</span> length(cplines{j})==1
                    cplines{j} = [];
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            obj.cLines = gd_cplines2plines(cplines);

            clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'mypoints'</span>,<span class="string">'mytext'</span>,<span class="string">'clines'</span>});
            ax = gd_plotpoints(obj.Axes,obj.pLines,<span class="string">'mylines'</span>,2);  <span class="comment">%set line</span>
            obj.Axes = gd_plotpoints(ax,obj.cLines,<span class="string">'clines'</span>,5);   <span class="comment">%set centre-lines</span>
            resetMenu(obj,false)
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> addLine(obj,~,~)
            <span class="comment">%order the lines to be in along-channel sequence</span>
            resetMenu(obj);
            <span class="comment">% prompt1 = sprintf('Add line\nSelect first point of section');</span>
            <span class="comment">% prompt2 = sprintf('Add line\nSelect second point of section');</span>
            <span class="comment">% prompts = {prompt1,prompt2};</span>
            promptcl= sprintf(<span class="string">'Add line\nLeft click to select centre-line, right click on a line to quit'</span>);
            promptcp = sprintf(<span class="string">'Add line\nLeft click to select centre-line point, right click to quit'</span>);

            clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'mypoints'</span>,<span class="string">'mytext'</span>,<span class="string">'clines'</span>});
            obj.Axes = gd_plotpoints(obj.Axes,obj.cLines,<span class="string">'clines'</span>,2);      <span class="comment">%set centre-lines</span>
            cpline = gd_getpline(obj.Axes,promptcl,<span class="string">'clines'</span>);              <span class="comment">%get line to add to</span>
            <span class="keyword">while</span>~isempty(cpline)
                <span class="comment">%gd_plotpoints(obj.Axes,obj.pLines,'mylines',2);            %show sections</span>
                gd_plotpoints(obj.Axes,cpline,<span class="string">'clines'</span>,5);                 <span class="comment">%show centre-line points</span>
                [NewPnt,Hc] = gd_setpoint(obj.Axes,promptcp,<span class="string">'clpoint'</span>,obj.isXYZ);
                <span class="keyword">while</span> ~isempty(NewPnt)
                    cpline = insertSection(obj,NewPnt,cpline);             <span class="comment">%insert new section</span>
                    delete(Hc);                                            <span class="comment">%delete digitising points</span>
                    gd_plotpoints(obj.Axes,NewPnt,<span class="string">'clines'</span>,5);             <span class="comment">%set centre-line point</span>
                    [NewPnt,Hc] = gd_setpoint(obj.Axes,promptcp,<span class="string">'clpoint'</span>,obj.isXYZ);
                <span class="keyword">end</span>
                clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'clines'</span>});
                gd_plotpoints(obj.Axes,obj.cLines,<span class="string">'clines'</span>,2);             <span class="comment">%set centre-lines</span>
                cpline = gd_getpline(obj.Axes,promptcl,<span class="string">'clines'</span>);          <span class="comment">%get line to add to</span>
            <span class="keyword">end</span>

            clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'clines'</span>});
            obj.Axes = gd_plotpoints(obj.Axes,obj.pLines,<span class="string">'mylines'</span>,2);<span class="comment">%set line</span>
            obj.Axes = gd_plotpoints(obj.Axes,obj.cLines,<span class="string">'clines'</span>,5); <span class="comment">%set centre-lines</span>
            resetMenu(obj,false)
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> deleteLine(obj,~,~)
            <span class="comment">%order the lines to be in along-channel sequence</span>
            resetMenu(obj);
            promptxt = sprintf(<span class="string">'Delete line\nSelect line to Delete, right click on any line to quit\nRedraw to update centre-line'</span>);
            [deline,H] = gd_getpline(obj.Axes,promptxt,<span class="string">'mylines'</span>);         <span class="comment">%get line to delete</span>
            <span class="keyword">while</span> ~isempty(deline)
                [obj.pLines,idl] = deleteAline(obj,<span class="string">'pLines'</span>,deline);       <span class="comment">%delete the line</span>
                delete(H)
                obj.cLines(idl) = [];                                      <span class="comment">%delete centre-line point</span>
                clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'clines'</span>});
                ax = gd_plotpoints(obj.Axes,obj.pLines,<span class="string">'mylines'</span>,2);       <span class="comment">%set line</span>
                gd_plotpoints(ax,obj.cLines,<span class="string">'clines'</span>,5);                   <span class="comment">%set centreline</span>
                deline = gd_getpline(obj.Axes,promptxt,<span class="string">'mylines'</span>);         <span class="comment">%get line to delete</span>
            <span class="keyword">end</span>
            resetLines(obj)
            resetMenu(obj,false)
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> Reset(obj,~,~)
            <span class="comment">%Reset to the input centre-line and boundary</span>
            clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'mypoints'</span>,<span class="string">'mytext'</span>,<span class="string">'clines'</span>});
            obj.cLines = gd_lines2points(obj.Set.ChannelLine);<span class="comment">%Centre line coordinates</span>
            gd_plotpoints(obj.Axes,obj.cLines,<span class="string">'clines'</span>,5);    <span class="comment">%5= plot as centre-lines</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> Redraw(obj,~,~)
            <span class="comment">%redraw the current set of points and lines</span>
            ax = obj.Axes;
            clearGraphics(obj,{<span class="string">'mylines'</span>,<span class="string">'clines'</span>});

            <span class="keyword">if</span> ~isempty(obj.pLines)
                ax = gd_plotpoints(ax,obj.pLines,<span class="string">'mylines'</span>,2); <span class="comment">%set line</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~isempty(obj.cLines)
                gd_plotpoints(ax,obj.cLines,<span class="string">'clines'</span>,5);       <span class="comment">%set centreline</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> Label(obj,~,~)
            <span class="comment">%toggline text section markers on and off</span>
            hpnts = findobj(obj.Axes,<span class="string">'Tag'</span>,<span class="string">'mytext'</span>);
            <span class="keyword">if</span> isempty(hpnts)           <span class="comment">%toggle points on</span>
                cplines = gd_plines2cplines(obj.pLines);
                <span class="keyword">for</span> i=1:length(cplines)
                    gd_plotpoints(obj.Axes,cplines{i},num2str(i),3);  <span class="comment">%set points</span>
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                clearGraphics(obj,{<span class="string">'mytext'</span>});
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">%  Utility functions to implement various actions</span>
<span class="comment">%--------------------------------------------------------------------------</span>
        <span class="keyword">function</span> plines = setSectionLines(~,cplines,clinedir,maxlen)
            <span class="comment">%create lines at right angles to the centre-line to define initial</span>
            <span class="comment">%sections</span>
            plines = [];
            <span class="keyword">for</span> i=1:length(cplines)
                sldirpos = [clinedir{i}]+pi()/2;
                sldirneg = [clinedir{i}]-pi()/2;
                lpnts = cplines{1,i};
                pospnts = sectionEndPoints(lpnts,sldirpos,maxlen);
                <span class="comment">%gd_plotpoints(ax,pospnts,'endpoints',1);</span>
                negpnts = sectionEndPoints(lpnts,sldirneg,maxlen);
                <span class="comment">%gd_plotpoints(ax,negpnts,'endpoints',1);</span>
                <span class="comment">%sections along ith length of centre-line</span>
                nanpnts.x = NaN; nanpnts.y = NaN;        <span class="comment">%line termination</span>
                <span class="keyword">for</span> j=1:length(pospnts)
                    plines = [plines,pospnts(j),negpnts(j),nanpnts]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">%nested function-------------------------------------------------------</span>
            <span class="keyword">function</span> endpnts  = sectionEndPoints(lpnts,sldir,maxlen)
                npnts = length(sldir);
                endpnts = [];
                <span class="keyword">for</span> k=1:npnts-1
                    p.x = lpnts(k).x+maxlen*cos(sldir(k));
                    p.y = lpnts(k).y+maxlen*sin(sldir(k));
                    endpnts = [endpnts,p]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span> <span class="comment">%------------------------------------------------------------------</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> [s_lines,idc] = clipSectionLines(obj,s_cplines,c_lines)
            <span class="comment">%find the nearest boundary point crossing positive and negative lines</span>
            b_lines = obj.Set.Boundary;
            s_lines = [];  spos = []; sneg = [];  idc = []; <span class="comment">%initialise loop variables</span>
            <span class="keyword">for</span> i=1:length(s_cplines)
                s_line = gd_points2lines(s_cplines{1,i},1);
                <span class="comment">%InterX input is 2 row vectors for x and y</span>
                P = InterX(s_line',[b_lines.x';b_lines.y']); <span class="comment">%intersections for 1 line</span>
                <span class="keyword">if</span> ~isempty(P)
                    cpnt = c_lines(i,:)';
                    <span class="comment">%find first intersections between centre-line and initial</span>
                    <span class="comment">%section end points</span>
                    <span class="comment">% hold on</span>
                    <span class="comment">% plot(obj.Axes,cpnt(1),cpnt(2),'ow','MarkerSize',8)</span>
                    <span class="comment">% hold off</span>
                    k = 1; l = 1;
                    <span class="keyword">for</span> j=1:size(P,2)
                        <span class="comment">%for each intersection point check whether point is on</span>
                        <span class="comment">%positive or negative side of line</span>
                        posline = [cpnt,s_line(1,:)'];
                        isp = ispointonline(posline,P(:,j),true,1e3); <span class="comment">%true=check ends</span>
                        <span class="keyword">if</span> isp
                            spos(:,k) = P(:,j); <span class="comment">%#ok&lt;AGROW&gt;</span>
                            k = k+1;
                        <span class="keyword">end</span>

                        negline = [cpnt,s_line(2,:)'];
                        isn = ispointonline(negline,P(:,j),true,1e3); <span class="comment">%true=check ends</span>
                        <span class="keyword">if</span> isn
                            sneg(:,l) = P(:,j); <span class="comment">%#ok&lt;AGROW&gt;</span>
                            l = l+1;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    <span class="comment">%</span>
                    <span class="keyword">if</span> isp || isn
                        spos = findNearest(spos,cpnt);
                        sneg = findNearest(sneg,cpnt);
                        <span class="keyword">if</span> ~isempty(spos) &amp;&amp;  ~isempty(sneg)
                            s_lines = [s_lines;spos';sneg';[NaN,NaN]];     <span class="comment">%#ok&lt;AGROW&gt;</span>
                        <span class="keyword">elseif</span> ~isempty(spos)
                            s_lines = [s_lines;spos';s_line(2,:);[NaN,NaN]];     <span class="comment">%#ok&lt;AGROW&gt;</span>
                        <span class="keyword">elseif</span> ~isempty(sneg)
                            s_lines = [s_lines;s_line(1,:);sneg';[NaN,NaN]];     <span class="comment">%#ok&lt;AGROW&gt;</span>
                        <span class="keyword">else</span>
                            idc = [idc,i]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                        <span class="keyword">end</span>
                    <span class="keyword">else</span>
                        <span class="comment">%no points found for centreline point - remove point</span>
                        idc = [idc,i]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                    <span class="keyword">end</span>
                    <span class="comment">% hold on</span>
                    <span class="comment">% pp = [spos,sneg];</span>
                    <span class="comment">% plot(obj.Axes,pp(1,:),pp(2,:),'ok')</span>
                    <span class="comment">% hold off</span>
                    spos = []; sneg = [];   <span class="comment">%clear for next iteration</span>
                <span class="keyword">else</span>
                    <span class="comment">%idc = [idc,i]; %#ok&lt;AGROW&gt;</span>
                    s_lines = [s_lines;s_line]; <span class="comment">%#ok&lt;AGROW&gt;</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">%nested function-----------------------------------------------</span>
            <span class="keyword">function</span> point = findNearest(points,cpnt)
                <span class="keyword">if</span> size(points,2)&gt;1
                    p = abs(points-cpnt);
                    D = hypot(p(1,:),p(2,:));
                    [~,idx] = min(D);
                    point = points(:,idx);
                <span class="keyword">else</span>
                    point = points;
                <span class="keyword">end</span>
            <span class="keyword">end</span> <span class="comment">%----------------------------------------------------------</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> cline = insertSection(obj,newpnt,cline)
            <span class="comment">%insert centre-line point on obj.cLines and cline</span>
            tol = obj.lineLength(cline(1),cline(2));
            [ison,idP] = obj.isPointNearLine(cline,newpnt,tol);
            <span class="keyword">if</span> ison
                <span class="comment">%insert the new centre-line point</span>
                [obj.cLines,~] = insertPoints(obj,<span class="string">'cLines'</span>,cline(idP([1,2])),newpnt);
            <span class="keyword">else</span>
                <span class="comment">%point not found in line so assume it is extending line</span>

                <span class="keyword">if</span> idP(1)==1 || idP(1)==length(cline)-1  <span class="comment">%starat or end of line</span>
                    obj.cLines = extendAline(obj,<span class="string">'cLines'</span>,newpnt,cline(idP(1)));
                <span class="keyword">else</span>
                    getdialog(sprintf(<span class="string">'Centre-line point not found\nSection not added to dataset'</span>))
                    <span class="keyword">return</span>;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            idL = gd_findline(obj.cLines,cline(1));
            cplines = gd_plines2cplines(obj.cLines);
            cline = cplines{1,idL};
            <span class="comment">%for each point use the centreline coordinates and</span>
            <span class="comment">%direction to define a section at right angles to the centreline</span>
            <span class="keyword">if</span> isempty(obj.xLength), setSectionLength(obj); <span class="keyword">end</span>
            <span class="comment">%set the length of the section lines</span>
            c_cplines = gd_plines2cplines(obj.cLines);
            [clinedir,c_cplines,~] = gd_curvelineprops(c_cplines,1);
            obj.pLines = setSectionLines(obj,c_cplines,clinedir,obj.xLength);
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> setSectionLength(obj)
            <span class="comment">%set the length of the section lines</span>
            inp = inputdlg({<span class="string">'Length of section lines from centre-line'</span>},<span class="string">'Sections'</span>,<span class="keyword">...</span>
                            1,{<span class="string">'1000'</span>});
            <span class="keyword">if</span> isempty(inp), inp{1} = <span class="string">'1000'</span>;  <span class="keyword">end</span>
            obj.xLength = str2double(inp{1});
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> plotSections(obj)
            <span class="comment">%plot the derived sections as editable lines</span>
            ax = obj.Axes;
            cplines = gd_plines2cplines(obj.pLines);
            <span class="keyword">for</span> j=1:length(cplines)                      <span class="comment">%call one at a time</span>
                aline = (cplines{1,j});                  <span class="comment">%to order numbering</span>
                ax = gd_plotpoints(ax,aline,<span class="string">'mylines'</span>,2);        <span class="comment">%set line</span>
                obj.Axes = gd_plotpoints(ax,aline,num2str(j),3); <span class="comment">%set labels</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> ax = plotGrid(obj,grid)
            <span class="comment">%plot either the bathymetry grid or an image of it as a backdrop;</span>
            hfig = obj.Figure;
            <span class="keyword">if</span> isstruct(grid)
                <span class="comment">%xyz grid is passed as the input variable</span>
                ax = gd_plotgrid(hfig,grid);
                hplt = findobj(ax,<span class="string">'Tag'</span>,<span class="string">'PlotGrid'</span>);
                hplt.Annotation.LegendInformation.IconDisplayStyle = <span class="string">'off'</span>;
            <span class="keyword">else</span>
                ax = axes(hfig);
                <span class="comment">%image is passed to class as the 'grid' input variable</span>
                img = grid.geoimage;     <span class="comment">%image object</span>
                h_im = imagesc(ax,<span class="string">'XData'</span>,img.XData,<span class="string">'YData'</span>,img.YData,<span class="string">'CData'</span>,img.CData);
                set(h_im, <span class="string">'AlphaData'</span>, 1-isnan(img.CData)); <span class="comment">%set Nan values to be transparent</span>
                cb = colormap(img.CMap);
                clim(img.CLim);
                cb.Label.String = <span class="string">'Elevation (mAD)'</span>;
            <span class="keyword">end</span>

            axis <span class="string">equal</span> <span class="string">tight</span>
        <span class="keyword">end</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> calltable = setSubMenus(obj)
            <span class="comment">%user defined menus to be appended to the Figure menu</span>
            varnames = {<span class="string">'Parent'</span>,<span class="string">'Callback'</span>,<span class="string">'Label'</span>};
            <span class="comment">%Boundary menu variables</span>
            stext = [<span class="string">"Set"</span>;<span class="string">"Clip"</span>;<span class="string">"Add"</span>;<span class="string">"Edit"</span>;<span class="string">"Delete"</span>;<span class="string">"Reset"</span>;<span class="string">"Label"</span>];
            scall = {@obj.setSections; @obj.clipLines; @obj.addLine; <span class="keyword">...</span>
                     @obj.editLine; @obj.deleteLine; @obj.Reset; @obj.Label};
            nrec = length(stext);
            spart = repmat(<span class="string">"Sections"</span>,nrec,1);
            calltable = table(spart,scall,stext,<span class="string">'VariableNames'</span>,varnames);
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">% Static utility functions</span>
<span class="comment">%--------------------------------------------------------------------------</span>
    methods (Static, Access=protected)
        <span class="comment">%Static methods in PLinterface</span>
        <span class="comment">% checkDirection</span>
        <span class="comment">% lineLength</span>
        <span class="comment">% isPointNearLine</span>
        <span class="comment">% setLevel</span>
        <span class="comment">% setInterval</span>
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef PL_SectionLines < PLinterface
%
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-class helpREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% NAME
%   PL_SectionLines.m
% PURPOSE
%   Class to create a set of cross-sections lines based on the points in a
%   centre-line and any enclosing boundary
% USAGE
%  
% SEE ALSO
%   inherits PLinterface
%
% Author: Ian Townend
% CoastalSEA (c) Feb 2025
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%    
    properties (Transient)
        %set Abstract properties for PLinterface
        outPoints = [] %not used but has to be set        
        isXYZ = false  %not used but has to be set
        outLines = []
        Set            %instance of PL_Sections class, or struct with 
                       %same field names
        cLines         %updated plines version of Set.ChannelLine (modified
                       %when sections are set but not saved)
        xLength        %half length of cross-sections
    end
       
    methods
        function obj = PL_SectionLines(figtitle,tag,position)          
            %constructor code: 
            if nargin<3, position = []; end
            obj = setFigure(obj,figtitle,tag,position);
        end 
    end
%% 
    methods (Static)  
        function [slines,clines] = Figure(grid,promptxt,sobj,isdel)
            %
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function helpREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % PURPOSE
            %   Figure to interactively edit points or lines
            % USAGE
            %   lines = PL_SectionLines.Figure(grid,promptxt,sobj,isdel);
            % INPUTS
            %   grid - struct of x, y, z (eg as used in getGrid in the GDinterface)
            %   promptxt- character string used for initial prompt in title
            %   sobj - instance of the PL_Sections class properties 
            %          Boundary, ChannelLine, and ChannelProps a struct
            %          for maximum water level, depth exponent and sampling
            %          interval (maxwl,dexp,cint)
            %   isdel - logical flag true to delete figure on completion - optional, 
            %           default is false
            % OUTPUTS
            %   lines - if lines are input, format is the same as the input, otherwise
            %           if nlines is scalar (default it type 2 if nlines empty)
            %            outype=0: array of structs with x, y and z fields defining selected points,
            %            outype=1: Nx2 or Nx3 array.
            %            outype=2: struct with x, y (and z) vector fields
            %            outype=3: table with x, y (and z) vector fields
            %            lines = [] if user closes figure, or no points defined
            % NOTES
            %   NB: if the figure window is closed the function returns lines=[] and
            %       not the input points
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            %
            if nargin<4, isdel = false; end
            figtitle = sprintf('Extract centre-line');
            tag = 'PlotFig'; %used for collective deletes of a group
            position = [0,0.03,1,0.93];
            obj = PL_SectionLines(figtitle,tag,position);

            %plot grid and initialise axes (needed for context menus)
            obj.Axes = plotGrid(obj,grid);            
            obj.Axes.Title.String = promptxt; %initial prompt

            %define menu to be used
            mtext = {'Sections','Figure'};
            mcall = repmat({[]},1,length(mtext));
            menu = struct('label',mtext,'callback',mcall);
            %default menus are defined for Point, Line and Figure include:
            % Line: 'Add','Edit','Extend','Insert','Join','Split','Delete'
            % Figure: 'View','Undo','Save','Save & Exit','Quit'
            %and are defined in PLinterface. getCallBacks
            %Bespoke options are then added by creating tables for each
            %addtional menu option in the function setSubMenus        
            submenus = setSubMenus(obj);
            %set the menus and submenus            
            obj = setMenu(obj,menu,submenus);
            obj.Set = sobj;                       %used to access PL_Sections for reset
            if ~isempty(sobj.Boundary)
                b_lines = obj.Set.Boundary;           %Boundary coordinates
                hold on
                plot(obj.Axes,b_lines.x,b_lines.y,'k','LineWidth',1);
                hold off;
            end
     
            obj.cLines = gd_lines2points(obj.Set.ChannelLine);%Centre line coordinates
            gd_plotpoints(obj.Axes,obj.cLines,'clines',5);    %5= plot as centre-lines

            %handle input of existing lines
            outype = getInLines(obj,obj.Set.SectionLines);

            obj.Figure.Visible = 'on';
            obj = waitForFigure(obj);

            if isempty(obj.outLines)
                slines = []; clines = [];
            else                
                slines = gd_points2lines(obj.outLines,outype.lines);
                clines = gd_points2lines(obj.cLines,outype.lines);
            end

            %delete figure if isdel has been set by call.
            if isdel
                delete(obj.Figure)
            end
        end
    end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Additional Menu callback functions
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
    methods (Access=protected)
        function setSections(obj,~,~)
            %use centreline to generate a set of sections    
            resetMenu(obj);
            clearGraphics(obj,{'mylines','mypoints','mytext'});
            setSectionLength(obj);

            %get user to define the mouth by defining a point near to a point on the
            %channel centre-line
            promptxt = 'Left click to set mouth point, right click to quit';
            ok = 0;
            axes(obj.Axes)
            tol = (abs(diff(xlim))+abs(diff(ylim)))/2/100; %(1e4+1e5)/2/100~O[300m]            
            while ok<1
                [mpnt,hp] = gd_setpoint(obj.Axes,promptxt,'startpoint',false);
                delete(hp)
                if isempty(mpnt)
                    ok = 2;  %user cancelled
                else
                   [isNear,idL] = PLinterface.isPointNearLine(obj.cLines,mpnt,tol);                        
                   if isNear
                       ok = 1; 
                   else
                       answer = questdlg('Could not find point. Try again?',...
                                              'Sections','Yes','No','Yes');
                       if strcmp(answer,'No'), ok = 2; end
                   end
                end
            end 
            %
            if ok==1
                %for each point from idL to the end use the centreline coordinates and
                %direction to define a section at right angles to the centreline
                c_cplines = gd_plines2cplines(obj.cLines);
                [clinedir,c_cplines,~] = gd_curvelineprops(c_cplines,idL(1));
            
                %generate the section lines for clinedir +pi/2 and -pi/2
                obj.pLines = setSectionLines(obj,c_cplines,clinedir,obj.xLength);
                obj.cLines = gd_cplines2plines(c_cplines);
                plotSections(obj);
            end
            resetMenu(obj,false)  
        end

%%
        function clipLines(obj,~,~)
            %clip the extent of the sections lines to a defined boundary
            resetMenu(obj);
            c_lines = obj.cLines;
            c_lines(isnan([c_lines(:).x])) = [];   %remove Nans so only points
            ncentres = length(c_lines);            %number of centreline points 

            s_cplines = gd_plines2cplines(obj.pLines);  %section lines
            nsections = length(s_cplines);
            if nsections~=ncentres
                warndlg('Number of sections do not match number of points on centre-lines')
                return;
            else
                c_lines = gd_points2lines(c_lines,1);
            end
            %crop lines to first crossing of boundary line
            [s_lines,idc] = clipSectionLines(obj,s_cplines,c_lines);
            obj.pLines = gd_lines2points(s_lines);

            %idc is the centre-line index of deleted points excluding NaNs
            for i=1:length(idc)
                 idd = find([obj.cLines(:).x]==c_lines(idc(i),1) & ...
                                    [obj.cLines(:).y]==c_lines(idc(i),2)); 
                 if ~isempty(idd), obj.cLines(idd) = []; end
            end

            %check that all points in a reach have not been deleted
            cplines = gd_plines2cplines(obj.cLines);
            for j=1:length(cplines)                
                if length(cplines{j})==1
                    cplines{j} = [];
                end
            end
            obj.cLines = gd_cplines2plines(cplines);

            clearGraphics(obj,{'mylines','mypoints','mytext','clines'});
            ax = gd_plotpoints(obj.Axes,obj.pLines,'mylines',2);  %set line  
            obj.Axes = gd_plotpoints(ax,obj.cLines,'clines',5);   %set centre-lines
            resetMenu(obj,false)  
        end

%%
        function addLine(obj,~,~)
            %order the lines to be in along-channel sequence
            resetMenu(obj);
            % prompt1 = sprintf('Add line\nSelect first point of section');   
            % prompt2 = sprintf('Add line\nSelect second point of section');
            % prompts = {prompt1,prompt2};
            promptcl= sprintf('Add line\nLeft click to select centre-line, right click on a line to quit');
            promptcp = sprintf('Add line\nLeft click to select centre-line point, right click to quit');

            clearGraphics(obj,{'mylines','mypoints','mytext','clines'});
            obj.Axes = gd_plotpoints(obj.Axes,obj.cLines,'clines',2);      %set centre-lines
            cpline = gd_getpline(obj.Axes,promptcl,'clines');              %get line to add to
            while~isempty(cpline)
                %gd_plotpoints(obj.Axes,obj.pLines,'mylines',2);            %show sections
                gd_plotpoints(obj.Axes,cpline,'clines',5);                 %show centre-line points
                [NewPnt,Hc] = gd_setpoint(obj.Axes,promptcp,'clpoint',obj.isXYZ); 
                while ~isempty(NewPnt)  
                    cpline = insertSection(obj,NewPnt,cpline);             %insert new section
                    delete(Hc);                                            %delete digitising points   
                    gd_plotpoints(obj.Axes,NewPnt,'clines',5);             %set centre-line point
                    [NewPnt,Hc] = gd_setpoint(obj.Axes,promptcp,'clpoint',obj.isXYZ);
                end
                clearGraphics(obj,{'mylines','clines'});
                gd_plotpoints(obj.Axes,obj.cLines,'clines',2);             %set centre-lines
                cpline = gd_getpline(obj.Axes,promptcl,'clines');          %get line to add to
            end

            clearGraphics(obj,{'mylines','clines'});
            obj.Axes = gd_plotpoints(obj.Axes,obj.pLines,'mylines',2);%set line  
            obj.Axes = gd_plotpoints(obj.Axes,obj.cLines,'clines',5); %set centre-lines
            resetMenu(obj,false)  
        end

%%
        function deleteLine(obj,~,~)
            %order the lines to be in along-channel sequence
            resetMenu(obj);
            promptxt = sprintf('Delete line\nSelect line to Delete, right click on any line to quit\nRedraw to update centre-line');
            [deline,H] = gd_getpline(obj.Axes,promptxt,'mylines');         %get line to delete
            while ~isempty(deline)                
                [obj.pLines,idl] = deleteAline(obj,'pLines',deline);       %delete the line
                delete(H)
                obj.cLines(idl) = [];                                      %delete centre-line point
                clearGraphics(obj,{'mylines','clines'});
                ax = gd_plotpoints(obj.Axes,obj.pLines,'mylines',2);       %set line 
                gd_plotpoints(ax,obj.cLines,'clines',5);                   %set centreline
                deline = gd_getpline(obj.Axes,promptxt,'mylines');         %get line to delete
            end
            resetLines(obj)
            resetMenu(obj,false)       
        end

%%
        function Reset(obj,~,~)
            %Reset to the input centre-line and boundary
            clearGraphics(obj,{'mylines','mypoints','mytext','clines'});
            obj.cLines = gd_lines2points(obj.Set.ChannelLine);%Centre line coordinates
            gd_plotpoints(obj.Axes,obj.cLines,'clines',5);    %5= plot as centre-lines            
        end

%%
        function Redraw(obj,~,~)
            %redraw the current set of points and lines
            ax = obj.Axes;            
            clearGraphics(obj,{'mylines','clines'});

            if ~isempty(obj.pLines)   
                ax = gd_plotpoints(ax,obj.pLines,'mylines',2); %set line          
            end
  
            if ~isempty(obj.cLines) 
                gd_plotpoints(ax,obj.cLines,'clines',5);       %set centreline
            end
        end  

%%
        function Label(obj,~,~)
            %toggline text section markers on and off
            hpnts = findobj(obj.Axes,'Tag','mytext');
            if isempty(hpnts)           %toggle points on
                cplines = gd_plines2cplines(obj.pLines);
                for i=1:length(cplines)
                    gd_plotpoints(obj.Axes,cplines{i},num2str(i),3);  %set points
                end
            else
                clearGraphics(obj,{'mytext'});
            end   
        end
%%
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%  Utility functions to implement various actions
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH 
        function plines = setSectionLines(~,cplines,clinedir,maxlen)
            %create lines at right angles to the centre-line to define initial
            %sections
            plines = [];
            for i=1:length(cplines)
                sldirpos = [clinedir{i}]+pi()/2;
                sldirneg = [clinedir{i}]-pi()/2;
                lpnts = cplines{1,i};
                pospnts = sectionEndPoints(lpnts,sldirpos,maxlen);
                %gd_plotpoints(ax,pospnts,'endpoints',1);
                negpnts = sectionEndPoints(lpnts,sldirneg,maxlen);
                %gd_plotpoints(ax,negpnts,'endpoints',1);      
                %sections along ith length of centre-line
                nanpnts.x = NaN; nanpnts.y = NaN;        %line termination
                for j=1:length(pospnts)
                    plines = [plines,pospnts(j),negpnts(j),nanpnts]; %#ok<AGROW> 
                end
            end
                
            %nested functionREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            function endpnts  = sectionEndPoints(lpnts,sldir,maxlen)
                npnts = length(sldir);
                endpnts = []; 
                for k=1:npnts-1
                    p.x = lpnts(k).x+maxlen*cos(sldir(k));
                    p.y = lpnts(k).y+maxlen*sin(sldir(k));
                    endpnts = [endpnts,p]; %#ok<AGROW> 
                end
            end %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        end

%%
        function [s_lines,idc] = clipSectionLines(obj,s_cplines,c_lines)
            %find the nearest boundary point crossing positive and negative lines
            b_lines = obj.Set.Boundary;
            s_lines = [];  spos = []; sneg = [];  idc = []; %initialise loop variables            
            for i=1:length(s_cplines)
                s_line = gd_points2lines(s_cplines{1,i},1);
                %InterX input is 2 row vectors for x and y
                P = InterX(s_line',[b_lines.x';b_lines.y']); %intersections for 1 line
                if ~isempty(P)
                    cpnt = c_lines(i,:)';
                    %find first intersections between centre-line and initial 
                    %section end points
                    % hold on
                    % plot(obj.Axes,cpnt(1),cpnt(2),'ow','MarkerSize',8)
                    % hold off                     
                    k = 1; l = 1;
                    for j=1:size(P,2)  
                        %for each intersection point check whether point is on
                        %positive or negative side of line
                        posline = [cpnt,s_line(1,:)'];   
                        isp = ispointonline(posline,P(:,j),true,1e3); %true=check ends
                        if isp
                            spos(:,k) = P(:,j); %#ok<AGROW> 
                            k = k+1;
                        end
        
                        negline = [cpnt,s_line(2,:)'];
                        isn = ispointonline(negline,P(:,j),true,1e3); %true=check ends
                        if isn
                            sneg(:,l) = P(:,j); %#ok<AGROW> 
                            l = l+1;
                        end
                    end
                    %
                    if isp || isn
                        spos = findNearest(spos,cpnt);
                        sneg = findNearest(sneg,cpnt);
                        if ~isempty(spos) &&  ~isempty(sneg)
                            s_lines = [s_lines;spos';sneg';[NaN,NaN]];     %#ok<AGROW> 
                        elseif ~isempty(spos)
                            s_lines = [s_lines;spos';s_line(2,:);[NaN,NaN]];     %#ok<AGROW> 
                        elseif ~isempty(sneg)
                            s_lines = [s_lines;s_line(1,:);sneg';[NaN,NaN]];     %#ok<AGROW> 
                        else 
                            idc = [idc,i]; %#ok<AGROW>
                        end
                    else
                        %no points found for centreline point - remove point
                        idc = [idc,i]; %#ok<AGROW>
                    end                    
                    % hold on
                    % pp = [spos,sneg];
                    % plot(obj.Axes,pp(1,:),pp(2,:),'ok')
                    % hold off   
                    spos = []; sneg = [];   %clear for next iteration
                else
                    %idc = [idc,i]; %#ok<AGROW>
                    s_lines = [s_lines;s_line]; %#ok<AGROW> 
                end
            end

            %nested functionREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            function point = findNearest(points,cpnt)
                if size(points,2)>1
                    p = abs(points-cpnt);
                    D = hypot(p(1,:),p(2,:));
                    [~,idx] = min(D);
                    point = points(:,idx);
                else
                    point = points;
                end
            end %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        end

%%
        function cline = insertSection(obj,newpnt,cline)
            %insert centre-line point on obj.cLines and cline
            tol = obj.lineLength(cline(1),cline(2));
            [ison,idP] = obj.isPointNearLine(cline,newpnt,tol);
            if ison
                %insert the new centre-line point
                [obj.cLines,~] = insertPoints(obj,'cLines',cline(idP([1,2])),newpnt);
            else
                %point not found in line so assume it is extending line
                
                if idP(1)==1 || idP(1)==length(cline)-1  %starat or end of line
                    obj.cLines = extendAline(obj,'cLines',newpnt,cline(idP(1)));
                else
                    getdialog(sprintf('Centre-line point not found\nSection not added to dataset'))
                    return;
                end                
            end
            idL = gd_findline(obj.cLines,cline(1));
            cplines = gd_plines2cplines(obj.cLines);
            cline = cplines{1,idL};
            %for each point use the centreline coordinates and
            %direction to define a section at right angles to the centreline
            if isempty(obj.xLength), setSectionLength(obj); end
            %set the length of the section lines 
            c_cplines = gd_plines2cplines(obj.cLines);
            [clinedir,c_cplines,~] = gd_curvelineprops(c_cplines,1);
            obj.pLines = setSectionLines(obj,c_cplines,clinedir,obj.xLength);
        end

%%
        function setSectionLength(obj)
            %set the length of the section lines
            inp = inputdlg({'Length of section lines from centre-line'},'Sections',...
                            1,{'1000'});
            if isempty(inp), inp{1} = '1000';  end
            obj.xLength = str2double(inp{1}); 
        end

%%
        function plotSections(obj)
            %plot the derived sections as editable lines
            ax = obj.Axes;
            cplines = gd_plines2cplines(obj.pLines);
            for j=1:length(cplines)                      %call one at a time
                aline = (cplines{1,j});                  %to order numbering
                ax = gd_plotpoints(ax,aline,'mylines',2);        %set line
                obj.Axes = gd_plotpoints(ax,aline,num2str(j),3); %set labels
            end
        end

%%
        function ax = plotGrid(obj,grid)
            %plot either the bathymetry grid or an image of it as a backdrop;
            hfig = obj.Figure;
            if isstruct(grid)
                %xyz grid is passed as the input variable
                ax = gd_plotgrid(hfig,grid);
                hplt = findobj(ax,'Tag','PlotGrid');
                hplt.Annotation.LegendInformation.IconDisplayStyle = 'off';  
            else
                ax = axes(hfig);
                %image is passed to class as the 'grid' input variable
                img = grid.geoimage;     %image object
                h_im = imagesc(ax,'XData',img.XData,'YData',img.YData,'CData',img.CData);
                set(h_im, 'AlphaData', 1-isnan(img.CData)); %set Nan values to be transparent   
                cb = colormap(img.CMap);
                clim(img.CLim);
                cb.Label.String = 'Elevation (mAD)'; 
            end

            axis equal tight
        end

%%
        function calltable = setSubMenus(obj)  
            %user defined menus to be appended to the Figure menu 
            varnames = {'Parent','Callback','Label'};
            %Boundary menu variables
            stext = ["Set";"Clip";"Add";"Edit";"Delete";"Reset";"Label"];
            scall = {@obj.setSections; @obj.clipLines; @obj.addLine; ...
                     @obj.editLine; @obj.deleteLine; @obj.Reset; @obj.Label}; 
            nrec = length(stext);
            spart = repmat("Sections",nrec,1);
            calltable = table(spart,scall,stext,'VariableNames',varnames);
        end
    end
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Static utility functions
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
    methods (Static, Access=protected)
        %Static methods in PLinterface
        % checkDirection
        % lineLength
        % isPointNearLine
        % setLevel
        % setInterval
    end
end
##### SOURCE END #####
--></body></html>